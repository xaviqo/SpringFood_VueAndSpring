{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/web.immediate.js\");\n\nvar fs = require('fs');\n\nvar util = require('util');\n\nvar stream = require('stream');\n\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\n\nvar Pend = require('pend');\n\nvar EventEmitter = require('events').EventEmitter;\n\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\nutil.inherits(FdSlicer, EventEmitter);\n\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\n\nFdSlicer.prototype.read = function (buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function (cb) {\n    fs.read(self.fd, buffer, offset, length, position, function (err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.write = function (buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function (cb) {\n    fs.write(self.fd, buffer, offset, length, position, function (err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.createReadStream = function (options) {\n  return new ReadStream(this, options);\n};\n\nFdSlicer.prototype.createWriteStream = function (options) {\n  return new WriteStream(this, options);\n};\n\nFdSlicer.prototype.ref = function () {\n  this.refCount += 1;\n};\n\nFdSlicer.prototype.unref = function () {\n  var self = this;\n  self.refCount -= 1;\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\n\nutil.inherits(ReadStream, Readable);\n\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n  this.context = context;\n  this.context.ref();\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\n\nReadStream.prototype._read = function (n) {\n  var self = this;\n  if (self.destroyed) return;\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n\n  self.context.pend.go(function (cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function (err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n\n      cb();\n    });\n  });\n};\n\nReadStream.prototype.destroy = function (err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\n\nutil.inherits(WriteStream, Writable);\n\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n  this.context = context;\n  this.context.ref();\n  this.start = options.start || 0;\n  this.endOffset = options.end == null ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n  this.on('finish', this.destroy.bind(this));\n}\n\nWriteStream.prototype._write = function (buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n\n  self.context.pend.go(function (cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function (err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\n\nWriteStream.prototype.destroy = function () {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\n\nutil.inherits(BufferSlicer, EventEmitter);\n\nfunction BufferSlicer(buffer, options) {\n  EventEmitter.call(this);\n  options = options || {};\n  this.refCount = 0;\n  this.buffer = buffer;\n  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;\n}\n\nBufferSlicer.prototype.read = function (buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = delta > 0 ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function () {\n    callback(null, written);\n  });\n};\n\nBufferSlicer.prototype.write = function (buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function () {\n    callback(null, length, buffer);\n  });\n};\n\nBufferSlicer.prototype.createReadStream = function (options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.destroyed = false;\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end; // by the time this function returns, we'll be done.\n\n  readStream.pos = readStream.endOffset || this.buffer.length; // respect the maxChunkSize option to slice up the chunk into smaller pieces.\n\n  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);\n  var offset = 0;\n\n  while (true) {\n    var nextOffset = offset + this.maxChunkSize;\n\n    if (nextOffset >= entireSlice.length) {\n      // last chunk\n      if (offset < entireSlice.length) {\n        readStream.write(entireSlice.slice(offset, entireSlice.length));\n      }\n\n      break;\n    }\n\n    readStream.write(entireSlice.slice(offset, nextOffset));\n    offset = nextOffset;\n  }\n\n  readStream.end();\n\n  readStream.destroy = function () {\n    readStream.destroyed = true;\n  };\n\n  return readStream;\n};\n\nBufferSlicer.prototype.createWriteStream = function (options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n\n  writeStream._write = function (buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n    var end = writeStream.pos + buffer.length;\n\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n\n  writeStream.destroy = function () {\n    writeStream.destroyed = true;\n  };\n\n  return writeStream;\n};\n\nBufferSlicer.prototype.ref = function () {\n  this.refCount += 1;\n};\n\nBufferSlicer.prototype.unref = function () {\n  this.refCount -= 1;\n\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\n\nfunction createFromBuffer(buffer, options) {\n  return new BufferSlicer(buffer, options);\n}\n\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}","map":{"version":3,"names":["fs","require","util","stream","Readable","Writable","PassThrough","Pend","EventEmitter","exports","createFromBuffer","createFromFd","BufferSlicer","FdSlicer","inherits","fd","options","call","pend","max","refCount","autoClose","prototype","read","buffer","offset","length","position","callback","self","go","cb","err","bytesRead","write","written","createReadStream","ReadStream","createWriteStream","WriteStream","ref","unref","Error","close","onCloseDone","emit","context","start","endOffset","end","pos","destroyed","_read","n","toRead","Math","min","_readableState","highWaterMark","push","Buffer","destroy","slice","Infinity","bytesWritten","on","bind","_write","encoding","code","bytes","maxChunkSize","Number","MAX_SAFE_INTEGER","delta","copy","setImmediate","readStream","entireSlice","nextOffset","bufferSlicer","writeStream"],"sources":["/home/xavi/Desktop/TRABAJOS/SpringFood/FE/springfood/node_modules/fd-slicer/index.js"],"sourcesContent":["var fs = require('fs');\nvar util = require('util');\nvar stream = require('stream');\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\nvar Pend = require('pend');\nvar EventEmitter = require('events').EventEmitter;\n\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\n\nutil.inherits(FdSlicer, EventEmitter);\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\n\nFdSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.createReadStream = function(options) {\n  return new ReadStream(this, options);\n};\n\nFdSlicer.prototype.createWriteStream = function(options) {\n  return new WriteStream(this, options);\n};\n\nFdSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nFdSlicer.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\n\nutil.inherits(ReadStream, Readable);\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\n\nReadStream.prototype._read = function(n) {\n  var self = this;\n  if (self.destroyed) return;\n\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n      cb();\n    });\n  });\n};\n\nReadStream.prototype.destroy = function(err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\n\nutil.inherits(WriteStream, Writable);\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = (options.end == null) ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n\n  this.on('finish', this.destroy.bind(this));\n}\n\nWriteStream.prototype._write = function(buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\n\nWriteStream.prototype.destroy = function() {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\n\nutil.inherits(BufferSlicer, EventEmitter);\nfunction BufferSlicer(buffer, options) {\n  EventEmitter.call(this);\n\n  options = options || {};\n  this.refCount = 0;\n  this.buffer = buffer;\n  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;\n}\n\nBufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = (delta > 0) ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function() {\n    callback(null, written);\n  });\n};\n\nBufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function() {\n    callback(null, length, buffer);\n  });\n};\n\nBufferSlicer.prototype.createReadStream = function(options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.destroyed = false;\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end;\n  // by the time this function returns, we'll be done.\n  readStream.pos = readStream.endOffset || this.buffer.length;\n\n  // respect the maxChunkSize option to slice up the chunk into smaller pieces.\n  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);\n  var offset = 0;\n  while (true) {\n    var nextOffset = offset + this.maxChunkSize;\n    if (nextOffset >= entireSlice.length) {\n      // last chunk\n      if (offset < entireSlice.length) {\n        readStream.write(entireSlice.slice(offset, entireSlice.length));\n      }\n      break;\n    }\n    readStream.write(entireSlice.slice(offset, nextOffset));\n    offset = nextOffset;\n  }\n\n  readStream.end();\n  readStream.destroy = function() {\n    readStream.destroyed = true;\n  };\n  return readStream;\n};\n\nBufferSlicer.prototype.createWriteStream = function(options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n  writeStream._write = function(buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n\n    var end = writeStream.pos + buffer.length;\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n  writeStream.destroy = function() {\n    writeStream.destroyed = true;\n  };\n  return writeStream;\n};\n\nBufferSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nBufferSlicer.prototype.unref = function() {\n  this.refCount -= 1;\n\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\n\nfunction createFromBuffer(buffer, options) {\n  return new BufferSlicer(buffer, options);\n}\n\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}