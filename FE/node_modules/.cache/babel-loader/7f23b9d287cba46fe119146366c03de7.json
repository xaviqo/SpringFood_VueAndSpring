{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/web.immediate.js\");\n\nvar fs = require(\"fs\");\n\nvar zlib = require(\"zlib\");\n\nvar fd_slicer = require(\"fd-slicer\");\n\nvar crc32 = require(\"buffer-crc32\");\n\nvar util = require(\"util\");\n\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar Transform = require(\"stream\").Transform;\n\nvar PassThrough = require(\"stream\").PassThrough;\n\nvar Writable = require(\"stream\").Writable;\n\nexports.open = open;\nexports.fromFd = fromFd;\nexports.fromBuffer = fromBuffer;\nexports.fromRandomAccessReader = fromRandomAccessReader;\nexports.dosDateTimeToDate = dosDateTimeToDate;\nexports.validateFileName = validateFileName;\nexports.ZipFile = ZipFile;\nexports.Entry = Entry;\nexports.RandomAccessReader = RandomAccessReader;\n\nfunction open(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.open(path, \"r\", function (err, fd) {\n    if (err) return callback(err);\n    fromFd(fd, options, function (err, zipfile) {\n      if (err) fs.close(fd, defaultCallback);\n      callback(err, zipfile);\n    });\n  });\n}\n\nfunction fromFd(fd, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.fstat(fd, function (err, stats) {\n    if (err) return callback(err);\n    var reader = fd_slicer.createFromFd(fd, {\n      autoClose: true\n    });\n    fromRandomAccessReader(reader, stats.size, options, callback);\n  });\n}\n\nfunction fromBuffer(buffer, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n\n  if (options == null) options = {};\n  options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false; // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87\n\n  var reader = fd_slicer.createFromBuffer(buffer, {\n    maxChunkSize: 0x10000\n  });\n  fromRandomAccessReader(reader, buffer.length, options, callback);\n}\n\nfunction fromRandomAccessReader(reader, totalSize, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  var decodeStrings = !!options.decodeStrings;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  if (typeof totalSize !== \"number\") throw new Error(\"expected totalSize parameter to be a number\");\n\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\");\n  } // the matching unref() call is in zipfile.close()\n\n\n  reader.ref(); // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n\n  var eocdrWithoutCommentSize = 22;\n  var maxCommentSize = 0xffff; // 2-byte size\n\n  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);\n  var buffer = newBuffer(bufferSize);\n  var bufferReadStart = totalSize - buffer.length;\n  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function (err) {\n    if (err) return callback(err);\n\n    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {\n      if (buffer.readUInt32LE(i) !== 0x06054b50) continue; // found eocdr\n\n      var eocdrBuffer = buffer.slice(i); // 0 - End of central directory signature = 0x06054b50\n      // 4 - Number of this disk\n\n      var diskNumber = eocdrBuffer.readUInt16LE(4);\n\n      if (diskNumber !== 0) {\n        return callback(new Error(\"multi-disk zip files are not supported: found disk number: \" + diskNumber));\n      } // 6 - Disk where central directory starts\n      // 8 - Number of central directory records on this disk\n      // 10 - Total number of central directory records\n\n\n      var entryCount = eocdrBuffer.readUInt16LE(10); // 12 - Size of central directory (bytes)\n      // 16 - Offset of start of central directory, relative to start of archive\n\n      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16); // 20 - Comment length\n\n      var commentLength = eocdrBuffer.readUInt16LE(20);\n      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;\n\n      if (commentLength !== expectedCommentLength) {\n        return callback(new Error(\"invalid comment length. expected: \" + expectedCommentLength + \". found: \" + commentLength));\n      } // 22 - Comment\n      // the encoding is always cp437.\n\n\n      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);\n\n      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n      } // ZIP64 format\n      // ZIP64 Zip64 end of central directory locator\n\n\n      var zip64EocdlBuffer = newBuffer(20);\n      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;\n      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function (err) {\n        if (err) return callback(err); // 0 - zip64 end of central dir locator signature = 0x07064b50\n\n        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {\n          return callback(new Error(\"invalid zip64 end of central directory locator signature\"));\n        } // 4 - number of the disk with the start of the zip64 end of central directory\n        // 8 - relative offset of the zip64 end of central directory record\n\n\n        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8); // 16 - total number of disks\n        // ZIP64 end of central directory record\n\n        var zip64EocdrBuffer = newBuffer(56);\n        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function (err) {\n          if (err) return callback(err); // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n\n          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {\n            return callback(new Error(\"invalid zip64 end of central directory record signature\"));\n          } // 4 - size of zip64 end of central directory record                8 bytes\n          // 12 - version made by                                             2 bytes\n          // 14 - version needed to extract                                   2 bytes\n          // 16 - number of this disk                                         4 bytes\n          // 20 - number of the disk with the start of the central directory  4 bytes\n          // 24 - total number of entries in the central directory on this disk         8 bytes\n          // 32 - total number of entries in the central directory            8 bytes\n\n\n          entryCount = readUInt64LE(zip64EocdrBuffer, 32); // 40 - size of the central directory                               8 bytes\n          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n\n          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48); // 56 - zip64 extensible data sector                                (variable size)\n\n          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n        });\n      });\n      return;\n    }\n\n    callback(new Error(\"end of central directory record signature not found\"));\n  });\n}\n\nutil.inherits(ZipFile, EventEmitter);\n\nfunction ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {\n  var self = this;\n  EventEmitter.call(self);\n  self.reader = reader; // forward close events\n\n  self.reader.on(\"error\", function (err) {\n    // error closing the fd\n    emitError(self, err);\n  });\n  self.reader.once(\"close\", function () {\n    self.emit(\"close\");\n  });\n  self.readEntryCursor = centralDirectoryOffset;\n  self.fileSize = fileSize;\n  self.entryCount = entryCount;\n  self.comment = comment;\n  self.entriesRead = 0;\n  self.autoClose = !!autoClose;\n  self.lazyEntries = !!lazyEntries;\n  self.decodeStrings = !!decodeStrings;\n  self.validateEntrySizes = !!validateEntrySizes;\n  self.strictFileNames = !!strictFileNames;\n  self.isOpen = true;\n  self.emittedError = false;\n  if (!self.lazyEntries) self._readEntry();\n}\n\nZipFile.prototype.close = function () {\n  if (!this.isOpen) return;\n  this.isOpen = false;\n  this.reader.unref();\n};\n\nfunction emitErrorAndAutoClose(self, err) {\n  if (self.autoClose) self.close();\n  emitError(self, err);\n}\n\nfunction emitError(self, err) {\n  if (self.emittedError) return;\n  self.emittedError = true;\n  self.emit(\"error\", err);\n}\n\nZipFile.prototype.readEntry = function () {\n  if (!this.lazyEntries) throw new Error(\"readEntry() called without lazyEntries:true\");\n\n  this._readEntry();\n};\n\nZipFile.prototype._readEntry = function () {\n  var self = this;\n\n  if (self.entryCount === self.entriesRead) {\n    // done with metadata\n    setImmediate(function () {\n      if (self.autoClose) self.close();\n      if (self.emittedError) return;\n      self.emit(\"end\");\n    });\n    return;\n  }\n\n  if (self.emittedError) return;\n  var buffer = newBuffer(46);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function (err) {\n    if (err) return emitErrorAndAutoClose(self, err);\n    if (self.emittedError) return;\n    var entry = new Entry(); // 0 - Central directory file header signature\n\n    var signature = buffer.readUInt32LE(0);\n    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error(\"invalid central directory file header signature: 0x\" + signature.toString(16))); // 4 - Version made by\n\n    entry.versionMadeBy = buffer.readUInt16LE(4); // 6 - Version needed to extract (minimum)\n\n    entry.versionNeededToExtract = buffer.readUInt16LE(6); // 8 - General purpose bit flag\n\n    entry.generalPurposeBitFlag = buffer.readUInt16LE(8); // 10 - Compression method\n\n    entry.compressionMethod = buffer.readUInt16LE(10); // 12 - File last modification time\n\n    entry.lastModFileTime = buffer.readUInt16LE(12); // 14 - File last modification date\n\n    entry.lastModFileDate = buffer.readUInt16LE(14); // 16 - CRC-32\n\n    entry.crc32 = buffer.readUInt32LE(16); // 20 - Compressed size\n\n    entry.compressedSize = buffer.readUInt32LE(20); // 24 - Uncompressed size\n\n    entry.uncompressedSize = buffer.readUInt32LE(24); // 28 - File name length (n)\n\n    entry.fileNameLength = buffer.readUInt16LE(28); // 30 - Extra field length (m)\n\n    entry.extraFieldLength = buffer.readUInt16LE(30); // 32 - File comment length (k)\n\n    entry.fileCommentLength = buffer.readUInt16LE(32); // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n\n    entry.internalFileAttributes = buffer.readUInt16LE(36); // 38 - External file attributes\n\n    entry.externalFileAttributes = buffer.readUInt32LE(38); // 42 - Relative offset of local file header\n\n    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);\n    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error(\"strong encryption is not supported\"));\n    self.readEntryCursor += 46;\n    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);\n    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function (err) {\n      if (err) return emitErrorAndAutoClose(self, err);\n      if (self.emittedError) return; // 46 - File name\n\n      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;\n      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength); // 46+n - Extra field\n\n      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;\n      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);\n      entry.extraFields = [];\n      var i = 0;\n\n      while (i < extraFieldBuffer.length - 3) {\n        var headerId = extraFieldBuffer.readUInt16LE(i + 0);\n        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);\n        var dataStart = i + 4;\n        var dataEnd = dataStart + dataSize;\n        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error(\"extra field length exceeds extra field buffer size\"));\n        var dataBuffer = newBuffer(dataSize);\n        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);\n        entry.extraFields.push({\n          id: headerId,\n          data: dataBuffer\n        });\n        i = dataEnd;\n      } // 46+n+m - File comment\n\n\n      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength); // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47\n\n      entry.comment = entry.fileComment;\n      self.readEntryCursor += buffer.length;\n      self.entriesRead += 1;\n\n      if (entry.uncompressedSize === 0xffffffff || entry.compressedSize === 0xffffffff || entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        // ZIP64 format\n        // find the Zip64 Extended Information Extra Field\n        var zip64EiefBuffer = null;\n\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n\n          if (extraField.id === 0x0001) {\n            zip64EiefBuffer = extraField.data;\n            break;\n          }\n        }\n\n        if (zip64EiefBuffer == null) {\n          return emitErrorAndAutoClose(self, new Error(\"expected zip64 extended information extra field\"));\n        }\n\n        var index = 0; // 0 - Original Size          8 bytes\n\n        if (entry.uncompressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include uncompressed size\"));\n          }\n\n          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        } // 8 - Compressed Size        8 bytes\n\n\n        if (entry.compressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include compressed size\"));\n          }\n\n          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        } // 16 - Relative Header Offset 8 bytes\n\n\n        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include relative header offset\"));\n          }\n\n          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        } // 24 - Disk Start Number      4 bytes\n\n      } // check for Info-ZIP Unicode Path Extra Field (0x7075)\n      // see https://github.com/thejoshwolfe/yauzl/issues/33\n\n\n      if (self.decodeStrings) {\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n\n          if (extraField.id === 0x7075) {\n            if (extraField.data.length < 6) {\n              // too short to be meaningful\n              continue;\n            } // Version       1 byte      version of this extra field, currently 1\n\n\n            if (extraField.data.readUInt8(0) !== 1) {\n              // > Changes may not be backward compatible so this extra\n              // > field should not be used if the version is not recognized.\n              continue;\n            } // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n\n\n            var oldNameCrc32 = extraField.data.readUInt32LE(1);\n\n            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {\n              // > If the CRC check fails, this UTF-8 Path Extra Field should be\n              // > ignored and the File Name field in the header should be used instead.\n              continue;\n            } // UnicodeName   Variable    UTF-8 version of the entry File Name\n\n\n            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);\n            break;\n          }\n        }\n      } // validate file size\n\n\n      if (self.validateEntrySizes && entry.compressionMethod === 0) {\n        var expectedCompressedSize = entry.uncompressedSize;\n\n        if (entry.isEncrypted()) {\n          // traditional encryption prefixes the file data with a header\n          expectedCompressedSize += 12;\n        }\n\n        if (entry.compressedSize !== expectedCompressedSize) {\n          var msg = \"compressed/uncompressed size mismatch for stored file: \" + entry.compressedSize + \" != \" + entry.uncompressedSize;\n          return emitErrorAndAutoClose(self, new Error(msg));\n        }\n      }\n\n      if (self.decodeStrings) {\n        if (!self.strictFileNames) {\n          // allow backslash\n          entry.fileName = entry.fileName.replace(/\\\\/g, \"/\");\n        }\n\n        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);\n        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));\n      }\n\n      self.emit(\"entry\", entry);\n      if (!self.lazyEntries) self._readEntry();\n    });\n  });\n};\n\nZipFile.prototype.openReadStream = function (entry, options, callback) {\n  var self = this; // parameter validation\n\n  var relativeStart = 0;\n  var relativeEnd = entry.compressedSize;\n\n  if (callback == null) {\n    callback = options;\n    options = {};\n  } else {\n    // validate options that the caller has no excuse to get wrong\n    if (options.decrypt != null) {\n      if (!entry.isEncrypted()) {\n        throw new Error(\"options.decrypt can only be specified for encrypted entries\");\n      }\n\n      if (options.decrypt !== false) throw new Error(\"invalid options.decrypt value: \" + options.decrypt);\n\n      if (entry.isCompressed()) {\n        if (options.decompress !== false) throw new Error(\"entry is encrypted and compressed, and options.decompress !== false\");\n      }\n    }\n\n    if (options.decompress != null) {\n      if (!entry.isCompressed()) {\n        throw new Error(\"options.decompress can only be specified for compressed entries\");\n      }\n\n      if (!(options.decompress === false || options.decompress === true)) {\n        throw new Error(\"invalid options.decompress value: \" + options.decompress);\n      }\n    }\n\n    if (options.start != null || options.end != null) {\n      if (entry.isCompressed() && options.decompress !== false) {\n        throw new Error(\"start/end range not allowed for compressed entry without options.decompress === false\");\n      }\n\n      if (entry.isEncrypted() && options.decrypt !== false) {\n        throw new Error(\"start/end range not allowed for encrypted entry without options.decrypt === false\");\n      }\n    }\n\n    if (options.start != null) {\n      relativeStart = options.start;\n      if (relativeStart < 0) throw new Error(\"options.start < 0\");\n      if (relativeStart > entry.compressedSize) throw new Error(\"options.start > entry.compressedSize\");\n    }\n\n    if (options.end != null) {\n      relativeEnd = options.end;\n      if (relativeEnd < 0) throw new Error(\"options.end < 0\");\n      if (relativeEnd > entry.compressedSize) throw new Error(\"options.end > entry.compressedSize\");\n      if (relativeEnd < relativeStart) throw new Error(\"options.end < options.start\");\n    }\n  } // any further errors can either be caused by the zipfile,\n  // or were introduced in a minor version of yauzl,\n  // so should be passed to the client rather than thrown.\n\n\n  if (!self.isOpen) return callback(new Error(\"closed\"));\n\n  if (entry.isEncrypted()) {\n    if (options.decrypt !== false) return callback(new Error(\"entry is encrypted, and options.decrypt !== false\"));\n  } // make sure we don't lose the fd before we open the actual read stream\n\n\n  self.reader.ref();\n  var buffer = newBuffer(30);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function (err) {\n    try {\n      if (err) return callback(err); // 0 - Local file header signature = 0x04034b50\n\n      var signature = buffer.readUInt32LE(0);\n\n      if (signature !== 0x04034b50) {\n        return callback(new Error(\"invalid local file header signature: 0x\" + signature.toString(16)));\n      } // all this should be redundant\n      // 4 - Version needed to extract (minimum)\n      // 6 - General purpose bit flag\n      // 8 - Compression method\n      // 10 - File last modification time\n      // 12 - File last modification date\n      // 14 - CRC-32\n      // 18 - Compressed size\n      // 22 - Uncompressed size\n      // 26 - File name length (n)\n\n\n      var fileNameLength = buffer.readUInt16LE(26); // 28 - Extra field length (m)\n\n      var extraFieldLength = buffer.readUInt16LE(28); // 30 - File name\n      // 30+n - Extra field\n\n      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n      var decompress;\n\n      if (entry.compressionMethod === 0) {\n        // 0 - The file is stored (no compression)\n        decompress = false;\n      } else if (entry.compressionMethod === 8) {\n        // 8 - The file is Deflated\n        decompress = options.decompress != null ? options.decompress : true;\n      } else {\n        return callback(new Error(\"unsupported compression method: \" + entry.compressionMethod));\n      }\n\n      var fileDataStart = localFileHeaderEnd;\n      var fileDataEnd = fileDataStart + entry.compressedSize;\n\n      if (entry.compressedSize !== 0) {\n        // bounds check now, because the read streams will probably not complain loud enough.\n        // since we're dealing with an unsigned offset plus an unsigned size,\n        // we only have 1 thing to check for.\n        if (fileDataEnd > self.fileSize) {\n          return callback(new Error(\"file data overflows file bounds: \" + fileDataStart + \" + \" + entry.compressedSize + \" > \" + self.fileSize));\n        }\n      }\n\n      var readStream = self.reader.createReadStream({\n        start: fileDataStart + relativeStart,\n        end: fileDataStart + relativeEnd\n      });\n      var endpointStream = readStream;\n\n      if (decompress) {\n        var destroyed = false;\n        var inflateFilter = zlib.createInflateRaw();\n        readStream.on(\"error\", function (err) {\n          // setImmediate here because errors can be emitted during the first call to pipe()\n          setImmediate(function () {\n            if (!destroyed) inflateFilter.emit(\"error\", err);\n          });\n        });\n        readStream.pipe(inflateFilter);\n\n        if (self.validateEntrySizes) {\n          endpointStream = new AssertByteCountStream(entry.uncompressedSize);\n          inflateFilter.on(\"error\", function (err) {\n            // forward zlib errors to the client-visible stream\n            setImmediate(function () {\n              if (!destroyed) endpointStream.emit(\"error\", err);\n            });\n          });\n          inflateFilter.pipe(endpointStream);\n        } else {\n          // the zlib filter is the client-visible stream\n          endpointStream = inflateFilter;\n        } // this is part of yauzl's API, so implement this function on the client-visible stream\n\n\n        endpointStream.destroy = function () {\n          destroyed = true;\n          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);\n          readStream.unpipe(inflateFilter); // TODO: the inflateFilter may cause a memory leak. see Issue #27.\n\n          readStream.destroy();\n        };\n      }\n\n      callback(null, endpointStream);\n    } finally {\n      self.reader.unref();\n    }\n  });\n};\n\nfunction Entry() {}\n\nEntry.prototype.getLastModDate = function () {\n  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);\n};\n\nEntry.prototype.isEncrypted = function () {\n  return (this.generalPurposeBitFlag & 0x1) !== 0;\n};\n\nEntry.prototype.isCompressed = function () {\n  return this.compressionMethod === 8;\n};\n\nfunction dosDateTimeToDate(date, time) {\n  var day = date & 0x1f; // 1-31\n\n  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n\n  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  var millisecond = 0;\n  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n\n  var minute = time >> 5 & 0x3f; // 0-59\n\n  var hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nfunction validateFileName(fileName) {\n  if (fileName.indexOf(\"\\\\\") !== -1) {\n    return \"invalid characters in fileName: \" + fileName;\n  }\n\n  if (/^[a-zA-Z]:/.test(fileName) || /^\\//.test(fileName)) {\n    return \"absolute path: \" + fileName;\n  }\n\n  if (fileName.split(\"/\").indexOf(\"..\") !== -1) {\n    return \"invalid relative path: \" + fileName;\n  } // all good\n\n\n  return null;\n}\n\nfunction readAndAssertNoEof(reader, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return setImmediate(function () {\n      callback(null, newBuffer(0));\n    });\n  }\n\n  reader.read(buffer, offset, length, position, function (err, bytesRead) {\n    if (err) return callback(err);\n\n    if (bytesRead < length) {\n      return callback(new Error(\"unexpected EOF\"));\n    }\n\n    callback();\n  });\n}\n\nutil.inherits(AssertByteCountStream, Transform);\n\nfunction AssertByteCountStream(byteCount) {\n  Transform.call(this);\n  this.actualByteCount = 0;\n  this.expectedByteCount = byteCount;\n}\n\nAssertByteCountStream.prototype._transform = function (chunk, encoding, cb) {\n  this.actualByteCount += chunk.length;\n\n  if (this.actualByteCount > this.expectedByteCount) {\n    var msg = \"too many bytes in the stream. expected \" + this.expectedByteCount + \". got at least \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n\n  cb(null, chunk);\n};\n\nAssertByteCountStream.prototype._flush = function (cb) {\n  if (this.actualByteCount < this.expectedByteCount) {\n    var msg = \"not enough bytes in the stream. expected \" + this.expectedByteCount + \". got only \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n\n  cb();\n};\n\nutil.inherits(RandomAccessReader, EventEmitter);\n\nfunction RandomAccessReader() {\n  EventEmitter.call(this);\n  this.refCount = 0;\n}\n\nRandomAccessReader.prototype.ref = function () {\n  this.refCount += 1;\n};\n\nRandomAccessReader.prototype.unref = function () {\n  var self = this;\n  self.refCount -= 1;\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n  self.close(onCloseDone);\n\n  function onCloseDone(err) {\n    if (err) return self.emit('error', err);\n    self.emit('close');\n  }\n};\n\nRandomAccessReader.prototype.createReadStream = function (options) {\n  var start = options.start;\n  var end = options.end;\n\n  if (start === end) {\n    var emptyStream = new PassThrough();\n    setImmediate(function () {\n      emptyStream.end();\n    });\n    return emptyStream;\n  }\n\n  var stream = this._readStreamForRange(start, end);\n\n  var destroyed = false;\n  var refUnrefFilter = new RefUnrefFilter(this);\n  stream.on(\"error\", function (err) {\n    setImmediate(function () {\n      if (!destroyed) refUnrefFilter.emit(\"error\", err);\n    });\n  });\n\n  refUnrefFilter.destroy = function () {\n    stream.unpipe(refUnrefFilter);\n    refUnrefFilter.unref();\n    stream.destroy();\n  };\n\n  var byteCounter = new AssertByteCountStream(end - start);\n  refUnrefFilter.on(\"error\", function (err) {\n    setImmediate(function () {\n      if (!destroyed) byteCounter.emit(\"error\", err);\n    });\n  });\n\n  byteCounter.destroy = function () {\n    destroyed = true;\n    refUnrefFilter.unpipe(byteCounter);\n    refUnrefFilter.destroy();\n  };\n\n  return stream.pipe(refUnrefFilter).pipe(byteCounter);\n};\n\nRandomAccessReader.prototype._readStreamForRange = function (start, end) {\n  throw new Error(\"not implemented\");\n};\n\nRandomAccessReader.prototype.read = function (buffer, offset, length, position, callback) {\n  var readStream = this.createReadStream({\n    start: position,\n    end: position + length\n  });\n  var writeStream = new Writable();\n  var written = 0;\n\n  writeStream._write = function (chunk, encoding, cb) {\n    chunk.copy(buffer, offset + written, 0, chunk.length);\n    written += chunk.length;\n    cb();\n  };\n\n  writeStream.on(\"finish\", callback);\n  readStream.on(\"error\", function (error) {\n    callback(error);\n  });\n  readStream.pipe(writeStream);\n};\n\nRandomAccessReader.prototype.close = function (callback) {\n  setImmediate(callback);\n};\n\nutil.inherits(RefUnrefFilter, PassThrough);\n\nfunction RefUnrefFilter(context) {\n  PassThrough.call(this);\n  this.context = context;\n  this.context.ref();\n  this.unreffedYet = false;\n}\n\nRefUnrefFilter.prototype._flush = function (cb) {\n  this.unref();\n  cb();\n};\n\nRefUnrefFilter.prototype.unref = function (cb) {\n  if (this.unreffedYet) return;\n  this.unreffedYet = true;\n  this.context.unref();\n};\n\nvar cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\n\nfunction decodeBuffer(buffer, start, end, isUtf8) {\n  if (isUtf8) {\n    return buffer.toString(\"utf8\", start, end);\n  } else {\n    var result = \"\";\n\n    for (var i = start; i < end; i++) {\n      result += cp437[buffer[i]];\n    }\n\n    return result;\n  }\n}\n\nfunction readUInt64LE(buffer, offset) {\n  // there is no native function for this, because we can't actually store 64-bit integers precisely.\n  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.\n  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.\n  var lower32 = buffer.readUInt32LE(offset);\n  var upper32 = buffer.readUInt32LE(offset + 4); // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.\n\n  return upper32 * 0x100000000 + lower32; // as long as we're bounds checking the result of this function against the total file size,\n  // we'll catch any overflow errors, because we already made sure the total file size was within reason.\n} // Node 10 deprecated new Buffer().\n\n\nvar newBuffer;\n\nif (typeof Buffer.allocUnsafe === \"function\") {\n  newBuffer = function (len) {\n    return Buffer.allocUnsafe(len);\n  };\n} else {\n  newBuffer = function (len) {\n    return new Buffer(len);\n  };\n}\n\nfunction defaultCallback(err) {\n  if (err) throw err;\n}","map":{"version":3,"names":["fs","require","zlib","fd_slicer","crc32","util","EventEmitter","Transform","PassThrough","Writable","exports","open","fromFd","fromBuffer","fromRandomAccessReader","dosDateTimeToDate","validateFileName","ZipFile","Entry","RandomAccessReader","path","options","callback","autoClose","lazyEntries","decodeStrings","validateEntrySizes","strictFileNames","defaultCallback","err","fd","zipfile","close","fstat","stats","reader","createFromFd","size","buffer","createFromBuffer","maxChunkSize","length","totalSize","Error","Number","MAX_SAFE_INTEGER","ref","eocdrWithoutCommentSize","maxCommentSize","bufferSize","Math","min","newBuffer","bufferReadStart","readAndAssertNoEof","i","readUInt32LE","eocdrBuffer","slice","diskNumber","readUInt16LE","entryCount","centralDirectoryOffset","commentLength","expectedCommentLength","comment","decodeBuffer","zip64EocdlBuffer","zip64EocdlOffset","zip64EocdrOffset","readUInt64LE","zip64EocdrBuffer","inherits","fileSize","self","call","on","emitError","once","emit","readEntryCursor","entriesRead","isOpen","emittedError","_readEntry","prototype","unref","emitErrorAndAutoClose","readEntry","setImmediate","entry","signature","toString","versionMadeBy","versionNeededToExtract","generalPurposeBitFlag","compressionMethod","lastModFileTime","lastModFileDate","compressedSize","uncompressedSize","fileNameLength","extraFieldLength","fileCommentLength","internalFileAttributes","externalFileAttributes","relativeOffsetOfLocalHeader","isUtf8","fileName","fileCommentStart","extraFieldBuffer","extraFields","headerId","dataSize","dataStart","dataEnd","dataBuffer","copy","push","id","data","fileComment","zip64EiefBuffer","extraField","index","readUInt8","oldNameCrc32","unsigned","expectedCompressedSize","isEncrypted","msg","replace","errorMessage","validateFileNameOptions","openReadStream","relativeStart","relativeEnd","decrypt","isCompressed","decompress","start","end","localFileHeaderEnd","fileDataStart","fileDataEnd","readStream","createReadStream","endpointStream","destroyed","inflateFilter","createInflateRaw","pipe","AssertByteCountStream","destroy","unpipe","getLastModDate","date","time","day","month","year","millisecond","second","minute","hour","Date","indexOf","test","split","offset","position","read","bytesRead","byteCount","actualByteCount","expectedByteCount","_transform","chunk","encoding","cb","_flush","refCount","onCloseDone","emptyStream","stream","_readStreamForRange","refUnrefFilter","RefUnrefFilter","byteCounter","writeStream","written","_write","error","context","unreffedYet","cp437","result","lower32","upper32","Buffer","allocUnsafe","len"],"sources":["/home/xavi/Desktop/TRABAJOS/SpringFood/FE/springfood/node_modules/yauzl/index.js"],"sourcesContent":["var fs = require(\"fs\");\nvar zlib = require(\"zlib\");\nvar fd_slicer = require(\"fd-slicer\");\nvar crc32 = require(\"buffer-crc32\");\nvar util = require(\"util\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar Transform = require(\"stream\").Transform;\nvar PassThrough = require(\"stream\").PassThrough;\nvar Writable = require(\"stream\").Writable;\n\nexports.open = open;\nexports.fromFd = fromFd;\nexports.fromBuffer = fromBuffer;\nexports.fromRandomAccessReader = fromRandomAccessReader;\nexports.dosDateTimeToDate = dosDateTimeToDate;\nexports.validateFileName = validateFileName;\nexports.ZipFile = ZipFile;\nexports.Entry = Entry;\nexports.RandomAccessReader = RandomAccessReader;\n\nfunction open(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.open(path, \"r\", function(err, fd) {\n    if (err) return callback(err);\n    fromFd(fd, options, function(err, zipfile) {\n      if (err) fs.close(fd, defaultCallback);\n      callback(err, zipfile);\n    });\n  });\n}\n\nfunction fromFd(fd, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.fstat(fd, function(err, stats) {\n    if (err) return callback(err);\n    var reader = fd_slicer.createFromFd(fd, {autoClose: true});\n    fromRandomAccessReader(reader, stats.size, options, callback);\n  });\n}\n\nfunction fromBuffer(buffer, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87\n  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});\n  fromRandomAccessReader(reader, buffer.length, options, callback);\n}\n\nfunction fromRandomAccessReader(reader, totalSize, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  var decodeStrings = !!options.decodeStrings;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  if (typeof totalSize !== \"number\") throw new Error(\"expected totalSize parameter to be a number\");\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\");\n  }\n\n  // the matching unref() call is in zipfile.close()\n  reader.ref();\n\n  // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n  var eocdrWithoutCommentSize = 22;\n  var maxCommentSize = 0xffff; // 2-byte size\n  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);\n  var buffer = newBuffer(bufferSize);\n  var bufferReadStart = totalSize - buffer.length;\n  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {\n    if (err) return callback(err);\n    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {\n      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;\n      // found eocdr\n      var eocdrBuffer = buffer.slice(i);\n\n      // 0 - End of central directory signature = 0x06054b50\n      // 4 - Number of this disk\n      var diskNumber = eocdrBuffer.readUInt16LE(4);\n      if (diskNumber !== 0) {\n        return callback(new Error(\"multi-disk zip files are not supported: found disk number: \" + diskNumber));\n      }\n      // 6 - Disk where central directory starts\n      // 8 - Number of central directory records on this disk\n      // 10 - Total number of central directory records\n      var entryCount = eocdrBuffer.readUInt16LE(10);\n      // 12 - Size of central directory (bytes)\n      // 16 - Offset of start of central directory, relative to start of archive\n      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);\n      // 20 - Comment length\n      var commentLength = eocdrBuffer.readUInt16LE(20);\n      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;\n      if (commentLength !== expectedCommentLength) {\n        return callback(new Error(\"invalid comment length. expected: \" + expectedCommentLength + \". found: \" + commentLength));\n      }\n      // 22 - Comment\n      // the encoding is always cp437.\n      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)\n                                  : eocdrBuffer.slice(22);\n\n      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n      }\n\n      // ZIP64 format\n\n      // ZIP64 Zip64 end of central directory locator\n      var zip64EocdlBuffer = newBuffer(20);\n      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;\n      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {\n        if (err) return callback(err);\n\n        // 0 - zip64 end of central dir locator signature = 0x07064b50\n        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {\n          return callback(new Error(\"invalid zip64 end of central directory locator signature\"));\n        }\n        // 4 - number of the disk with the start of the zip64 end of central directory\n        // 8 - relative offset of the zip64 end of central directory record\n        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);\n        // 16 - total number of disks\n\n        // ZIP64 end of central directory record\n        var zip64EocdrBuffer = newBuffer(56);\n        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {\n          if (err) return callback(err);\n\n          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {\n            return callback(new Error(\"invalid zip64 end of central directory record signature\"));\n          }\n          // 4 - size of zip64 end of central directory record                8 bytes\n          // 12 - version made by                                             2 bytes\n          // 14 - version needed to extract                                   2 bytes\n          // 16 - number of this disk                                         4 bytes\n          // 20 - number of the disk with the start of the central directory  4 bytes\n          // 24 - total number of entries in the central directory on this disk         8 bytes\n          // 32 - total number of entries in the central directory            8 bytes\n          entryCount = readUInt64LE(zip64EocdrBuffer, 32);\n          // 40 - size of the central directory                               8 bytes\n          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);\n          // 56 - zip64 extensible data sector                                (variable size)\n          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n        });\n      });\n      return;\n    }\n    callback(new Error(\"end of central directory record signature not found\"));\n  });\n}\n\nutil.inherits(ZipFile, EventEmitter);\nfunction ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {\n  var self = this;\n  EventEmitter.call(self);\n  self.reader = reader;\n  // forward close events\n  self.reader.on(\"error\", function(err) {\n    // error closing the fd\n    emitError(self, err);\n  });\n  self.reader.once(\"close\", function() {\n    self.emit(\"close\");\n  });\n  self.readEntryCursor = centralDirectoryOffset;\n  self.fileSize = fileSize;\n  self.entryCount = entryCount;\n  self.comment = comment;\n  self.entriesRead = 0;\n  self.autoClose = !!autoClose;\n  self.lazyEntries = !!lazyEntries;\n  self.decodeStrings = !!decodeStrings;\n  self.validateEntrySizes = !!validateEntrySizes;\n  self.strictFileNames = !!strictFileNames;\n  self.isOpen = true;\n  self.emittedError = false;\n\n  if (!self.lazyEntries) self._readEntry();\n}\nZipFile.prototype.close = function() {\n  if (!this.isOpen) return;\n  this.isOpen = false;\n  this.reader.unref();\n};\n\nfunction emitErrorAndAutoClose(self, err) {\n  if (self.autoClose) self.close();\n  emitError(self, err);\n}\nfunction emitError(self, err) {\n  if (self.emittedError) return;\n  self.emittedError = true;\n  self.emit(\"error\", err);\n}\n\nZipFile.prototype.readEntry = function() {\n  if (!this.lazyEntries) throw new Error(\"readEntry() called without lazyEntries:true\");\n  this._readEntry();\n};\nZipFile.prototype._readEntry = function() {\n  var self = this;\n  if (self.entryCount === self.entriesRead) {\n    // done with metadata\n    setImmediate(function() {\n      if (self.autoClose) self.close();\n      if (self.emittedError) return;\n      self.emit(\"end\");\n    });\n    return;\n  }\n  if (self.emittedError) return;\n  var buffer = newBuffer(46);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n    if (err) return emitErrorAndAutoClose(self, err);\n    if (self.emittedError) return;\n    var entry = new Entry();\n    // 0 - Central directory file header signature\n    var signature = buffer.readUInt32LE(0);\n    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error(\"invalid central directory file header signature: 0x\" + signature.toString(16)));\n    // 4 - Version made by\n    entry.versionMadeBy = buffer.readUInt16LE(4);\n    // 6 - Version needed to extract (minimum)\n    entry.versionNeededToExtract = buffer.readUInt16LE(6);\n    // 8 - General purpose bit flag\n    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);\n    // 10 - Compression method\n    entry.compressionMethod = buffer.readUInt16LE(10);\n    // 12 - File last modification time\n    entry.lastModFileTime = buffer.readUInt16LE(12);\n    // 14 - File last modification date\n    entry.lastModFileDate = buffer.readUInt16LE(14);\n    // 16 - CRC-32\n    entry.crc32 = buffer.readUInt32LE(16);\n    // 20 - Compressed size\n    entry.compressedSize = buffer.readUInt32LE(20);\n    // 24 - Uncompressed size\n    entry.uncompressedSize = buffer.readUInt32LE(24);\n    // 28 - File name length (n)\n    entry.fileNameLength = buffer.readUInt16LE(28);\n    // 30 - Extra field length (m)\n    entry.extraFieldLength = buffer.readUInt16LE(30);\n    // 32 - File comment length (k)\n    entry.fileCommentLength = buffer.readUInt16LE(32);\n    // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n    entry.internalFileAttributes = buffer.readUInt16LE(36);\n    // 38 - External file attributes\n    entry.externalFileAttributes = buffer.readUInt32LE(38);\n    // 42 - Relative offset of local file header\n    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);\n\n    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error(\"strong encryption is not supported\"));\n\n    self.readEntryCursor += 46;\n\n    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);\n    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n      if (err) return emitErrorAndAutoClose(self, err);\n      if (self.emittedError) return;\n      // 46 - File name\n      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;\n      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)\n                                          : buffer.slice(0, entry.fileNameLength);\n\n      // 46+n - Extra field\n      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;\n      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);\n      entry.extraFields = [];\n      var i = 0;\n      while (i < extraFieldBuffer.length - 3) {\n        var headerId = extraFieldBuffer.readUInt16LE(i + 0);\n        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);\n        var dataStart = i + 4;\n        var dataEnd = dataStart + dataSize;\n        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error(\"extra field length exceeds extra field buffer size\"));\n        var dataBuffer = newBuffer(dataSize);\n        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);\n        entry.extraFields.push({\n          id: headerId,\n          data: dataBuffer,\n        });\n        i = dataEnd;\n      }\n\n      // 46+n+m - File comment\n      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)\n                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);\n      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47\n      entry.comment = entry.fileComment;\n\n      self.readEntryCursor += buffer.length;\n      self.entriesRead += 1;\n\n      if (entry.uncompressedSize            === 0xffffffff ||\n          entry.compressedSize              === 0xffffffff ||\n          entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        // ZIP64 format\n        // find the Zip64 Extended Information Extra Field\n        var zip64EiefBuffer = null;\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x0001) {\n            zip64EiefBuffer = extraField.data;\n            break;\n          }\n        }\n        if (zip64EiefBuffer == null) {\n          return emitErrorAndAutoClose(self, new Error(\"expected zip64 extended information extra field\"));\n        }\n        var index = 0;\n        // 0 - Original Size          8 bytes\n        if (entry.uncompressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include uncompressed size\"));\n          }\n          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 8 - Compressed Size        8 bytes\n        if (entry.compressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include compressed size\"));\n          }\n          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 16 - Relative Header Offset 8 bytes\n        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include relative header offset\"));\n          }\n          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 24 - Disk Start Number      4 bytes\n      }\n\n      // check for Info-ZIP Unicode Path Extra Field (0x7075)\n      // see https://github.com/thejoshwolfe/yauzl/issues/33\n      if (self.decodeStrings) {\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x7075) {\n            if (extraField.data.length < 6) {\n              // too short to be meaningful\n              continue;\n            }\n            // Version       1 byte      version of this extra field, currently 1\n            if (extraField.data.readUInt8(0) !== 1) {\n              // > Changes may not be backward compatible so this extra\n              // > field should not be used if the version is not recognized.\n              continue;\n            }\n            // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n            var oldNameCrc32 = extraField.data.readUInt32LE(1);\n            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {\n              // > If the CRC check fails, this UTF-8 Path Extra Field should be\n              // > ignored and the File Name field in the header should be used instead.\n              continue;\n            }\n            // UnicodeName   Variable    UTF-8 version of the entry File Name\n            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);\n            break;\n          }\n        }\n      }\n\n      // validate file size\n      if (self.validateEntrySizes && entry.compressionMethod === 0) {\n        var expectedCompressedSize = entry.uncompressedSize;\n        if (entry.isEncrypted()) {\n          // traditional encryption prefixes the file data with a header\n          expectedCompressedSize += 12;\n        }\n        if (entry.compressedSize !== expectedCompressedSize) {\n          var msg = \"compressed/uncompressed size mismatch for stored file: \" + entry.compressedSize + \" != \" + entry.uncompressedSize;\n          return emitErrorAndAutoClose(self, new Error(msg));\n        }\n      }\n\n      if (self.decodeStrings) {\n        if (!self.strictFileNames) {\n          // allow backslash\n          entry.fileName = entry.fileName.replace(/\\\\/g, \"/\");\n        }\n        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);\n        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));\n      }\n      self.emit(\"entry\", entry);\n\n      if (!self.lazyEntries) self._readEntry();\n    });\n  });\n};\n\nZipFile.prototype.openReadStream = function(entry, options, callback) {\n  var self = this;\n  // parameter validation\n  var relativeStart = 0;\n  var relativeEnd = entry.compressedSize;\n  if (callback == null) {\n    callback = options;\n    options = {};\n  } else {\n    // validate options that the caller has no excuse to get wrong\n    if (options.decrypt != null) {\n      if (!entry.isEncrypted()) {\n        throw new Error(\"options.decrypt can only be specified for encrypted entries\");\n      }\n      if (options.decrypt !== false) throw new Error(\"invalid options.decrypt value: \" + options.decrypt);\n      if (entry.isCompressed()) {\n        if (options.decompress !== false) throw new Error(\"entry is encrypted and compressed, and options.decompress !== false\");\n      }\n    }\n    if (options.decompress != null) {\n      if (!entry.isCompressed()) {\n        throw new Error(\"options.decompress can only be specified for compressed entries\");\n      }\n      if (!(options.decompress === false || options.decompress === true)) {\n        throw new Error(\"invalid options.decompress value: \" + options.decompress);\n      }\n    }\n    if (options.start != null || options.end != null) {\n      if (entry.isCompressed() && options.decompress !== false) {\n        throw new Error(\"start/end range not allowed for compressed entry without options.decompress === false\");\n      }\n      if (entry.isEncrypted() && options.decrypt !== false) {\n        throw new Error(\"start/end range not allowed for encrypted entry without options.decrypt === false\");\n      }\n    }\n    if (options.start != null) {\n      relativeStart = options.start;\n      if (relativeStart < 0) throw new Error(\"options.start < 0\");\n      if (relativeStart > entry.compressedSize) throw new Error(\"options.start > entry.compressedSize\");\n    }\n    if (options.end != null) {\n      relativeEnd = options.end;\n      if (relativeEnd < 0) throw new Error(\"options.end < 0\");\n      if (relativeEnd > entry.compressedSize) throw new Error(\"options.end > entry.compressedSize\");\n      if (relativeEnd < relativeStart) throw new Error(\"options.end < options.start\");\n    }\n  }\n  // any further errors can either be caused by the zipfile,\n  // or were introduced in a minor version of yauzl,\n  // so should be passed to the client rather than thrown.\n  if (!self.isOpen) return callback(new Error(\"closed\"));\n  if (entry.isEncrypted()) {\n    if (options.decrypt !== false) return callback(new Error(\"entry is encrypted, and options.decrypt !== false\"));\n  }\n  // make sure we don't lose the fd before we open the actual read stream\n  self.reader.ref();\n  var buffer = newBuffer(30);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {\n    try {\n      if (err) return callback(err);\n      // 0 - Local file header signature = 0x04034b50\n      var signature = buffer.readUInt32LE(0);\n      if (signature !== 0x04034b50) {\n        return callback(new Error(\"invalid local file header signature: 0x\" + signature.toString(16)));\n      }\n      // all this should be redundant\n      // 4 - Version needed to extract (minimum)\n      // 6 - General purpose bit flag\n      // 8 - Compression method\n      // 10 - File last modification time\n      // 12 - File last modification date\n      // 14 - CRC-32\n      // 18 - Compressed size\n      // 22 - Uncompressed size\n      // 26 - File name length (n)\n      var fileNameLength = buffer.readUInt16LE(26);\n      // 28 - Extra field length (m)\n      var extraFieldLength = buffer.readUInt16LE(28);\n      // 30 - File name\n      // 30+n - Extra field\n      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n      var decompress;\n      if (entry.compressionMethod === 0) {\n        // 0 - The file is stored (no compression)\n        decompress = false;\n      } else if (entry.compressionMethod === 8) {\n        // 8 - The file is Deflated\n        decompress = options.decompress != null ? options.decompress : true;\n      } else {\n        return callback(new Error(\"unsupported compression method: \" + entry.compressionMethod));\n      }\n      var fileDataStart = localFileHeaderEnd;\n      var fileDataEnd = fileDataStart + entry.compressedSize;\n      if (entry.compressedSize !== 0) {\n        // bounds check now, because the read streams will probably not complain loud enough.\n        // since we're dealing with an unsigned offset plus an unsigned size,\n        // we only have 1 thing to check for.\n        if (fileDataEnd > self.fileSize) {\n          return callback(new Error(\"file data overflows file bounds: \" +\n              fileDataStart + \" + \" + entry.compressedSize + \" > \" + self.fileSize));\n        }\n      }\n      var readStream = self.reader.createReadStream({\n        start: fileDataStart + relativeStart,\n        end: fileDataStart + relativeEnd,\n      });\n      var endpointStream = readStream;\n      if (decompress) {\n        var destroyed = false;\n        var inflateFilter = zlib.createInflateRaw();\n        readStream.on(\"error\", function(err) {\n          // setImmediate here because errors can be emitted during the first call to pipe()\n          setImmediate(function() {\n            if (!destroyed) inflateFilter.emit(\"error\", err);\n          });\n        });\n        readStream.pipe(inflateFilter);\n\n        if (self.validateEntrySizes) {\n          endpointStream = new AssertByteCountStream(entry.uncompressedSize);\n          inflateFilter.on(\"error\", function(err) {\n            // forward zlib errors to the client-visible stream\n            setImmediate(function() {\n              if (!destroyed) endpointStream.emit(\"error\", err);\n            });\n          });\n          inflateFilter.pipe(endpointStream);\n        } else {\n          // the zlib filter is the client-visible stream\n          endpointStream = inflateFilter;\n        }\n        // this is part of yauzl's API, so implement this function on the client-visible stream\n        endpointStream.destroy = function() {\n          destroyed = true;\n          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);\n          readStream.unpipe(inflateFilter);\n          // TODO: the inflateFilter may cause a memory leak. see Issue #27.\n          readStream.destroy();\n        };\n      }\n      callback(null, endpointStream);\n    } finally {\n      self.reader.unref();\n    }\n  });\n};\n\nfunction Entry() {\n}\nEntry.prototype.getLastModDate = function() {\n  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);\n};\nEntry.prototype.isEncrypted = function() {\n  return (this.generalPurposeBitFlag & 0x1) !== 0;\n};\nEntry.prototype.isCompressed = function() {\n  return this.compressionMethod === 8;\n};\n\nfunction dosDateTimeToDate(date, time) {\n  var day = date & 0x1f; // 1-31\n  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  var millisecond = 0;\n  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  var minute = time >> 5 & 0x3f; // 0-59\n  var hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nfunction validateFileName(fileName) {\n  if (fileName.indexOf(\"\\\\\") !== -1) {\n    return \"invalid characters in fileName: \" + fileName;\n  }\n  if (/^[a-zA-Z]:/.test(fileName) || /^\\//.test(fileName)) {\n    return \"absolute path: \" + fileName;\n  }\n  if (fileName.split(\"/\").indexOf(\"..\") !== -1) {\n    return \"invalid relative path: \" + fileName;\n  }\n  // all good\n  return null;\n}\n\nfunction readAndAssertNoEof(reader, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return setImmediate(function() { callback(null, newBuffer(0)); });\n  }\n  reader.read(buffer, offset, length, position, function(err, bytesRead) {\n    if (err) return callback(err);\n    if (bytesRead < length) {\n      return callback(new Error(\"unexpected EOF\"));\n    }\n    callback();\n  });\n}\n\nutil.inherits(AssertByteCountStream, Transform);\nfunction AssertByteCountStream(byteCount) {\n  Transform.call(this);\n  this.actualByteCount = 0;\n  this.expectedByteCount = byteCount;\n}\nAssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {\n  this.actualByteCount += chunk.length;\n  if (this.actualByteCount > this.expectedByteCount) {\n    var msg = \"too many bytes in the stream. expected \" + this.expectedByteCount + \". got at least \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb(null, chunk);\n};\nAssertByteCountStream.prototype._flush = function(cb) {\n  if (this.actualByteCount < this.expectedByteCount) {\n    var msg = \"not enough bytes in the stream. expected \" + this.expectedByteCount + \". got only \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb();\n};\n\nutil.inherits(RandomAccessReader, EventEmitter);\nfunction RandomAccessReader() {\n  EventEmitter.call(this);\n  this.refCount = 0;\n}\nRandomAccessReader.prototype.ref = function() {\n  this.refCount += 1;\n};\nRandomAccessReader.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  self.close(onCloseDone);\n\n  function onCloseDone(err) {\n    if (err) return self.emit('error', err);\n    self.emit('close');\n  }\n};\nRandomAccessReader.prototype.createReadStream = function(options) {\n  var start = options.start;\n  var end = options.end;\n  if (start === end) {\n    var emptyStream = new PassThrough();\n    setImmediate(function() {\n      emptyStream.end();\n    });\n    return emptyStream;\n  }\n  var stream = this._readStreamForRange(start, end);\n\n  var destroyed = false;\n  var refUnrefFilter = new RefUnrefFilter(this);\n  stream.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) refUnrefFilter.emit(\"error\", err);\n    });\n  });\n  refUnrefFilter.destroy = function() {\n    stream.unpipe(refUnrefFilter);\n    refUnrefFilter.unref();\n    stream.destroy();\n  };\n\n  var byteCounter = new AssertByteCountStream(end - start);\n  refUnrefFilter.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) byteCounter.emit(\"error\", err);\n    });\n  });\n  byteCounter.destroy = function() {\n    destroyed = true;\n    refUnrefFilter.unpipe(byteCounter);\n    refUnrefFilter.destroy();\n  };\n\n  return stream.pipe(refUnrefFilter).pipe(byteCounter);\n};\nRandomAccessReader.prototype._readStreamForRange = function(start, end) {\n  throw new Error(\"not implemented\");\n};\nRandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {\n  var readStream = this.createReadStream({start: position, end: position + length});\n  var writeStream = new Writable();\n  var written = 0;\n  writeStream._write = function(chunk, encoding, cb) {\n    chunk.copy(buffer, offset + written, 0, chunk.length);\n    written += chunk.length;\n    cb();\n  };\n  writeStream.on(\"finish\", callback);\n  readStream.on(\"error\", function(error) {\n    callback(error);\n  });\n  readStream.pipe(writeStream);\n};\nRandomAccessReader.prototype.close = function(callback) {\n  setImmediate(callback);\n};\n\nutil.inherits(RefUnrefFilter, PassThrough);\nfunction RefUnrefFilter(context) {\n  PassThrough.call(this);\n  this.context = context;\n  this.context.ref();\n  this.unreffedYet = false;\n}\nRefUnrefFilter.prototype._flush = function(cb) {\n  this.unref();\n  cb();\n};\nRefUnrefFilter.prototype.unref = function(cb) {\n  if (this.unreffedYet) return;\n  this.unreffedYet = true;\n  this.context.unref();\n};\n\nvar cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\nfunction decodeBuffer(buffer, start, end, isUtf8) {\n  if (isUtf8) {\n    return buffer.toString(\"utf8\", start, end);\n  } else {\n    var result = \"\";\n    for (var i = start; i < end; i++) {\n      result += cp437[buffer[i]];\n    }\n    return result;\n  }\n}\n\nfunction readUInt64LE(buffer, offset) {\n  // there is no native function for this, because we can't actually store 64-bit integers precisely.\n  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.\n  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.\n  var lower32 = buffer.readUInt32LE(offset);\n  var upper32 = buffer.readUInt32LE(offset + 4);\n  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.\n  return upper32 * 0x100000000 + lower32;\n  // as long as we're bounds checking the result of this function against the total file size,\n  // we'll catch any overflow errors, because we already made sure the total file size was within reason.\n}\n\n// Node 10 deprecated new Buffer().\nvar newBuffer;\nif (typeof Buffer.allocUnsafe === \"function\") {\n  newBuffer = function(len) {\n    return Buffer.allocUnsafe(len);\n  };\n} else {\n  newBuffer = function(len) {\n    return new Buffer(len);\n  };\n}\n\nfunction defaultCallback(err) {\n  if (err) throw err;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}