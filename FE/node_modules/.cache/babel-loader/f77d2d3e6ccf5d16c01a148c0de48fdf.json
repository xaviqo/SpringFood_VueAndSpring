{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nconst _ = require(\"lodash\");\n\nconst path = require(\"path\");\n\nconst yauzl = require(\"yauzl\");\n\nconst fetch = require(\"node-fetch\");\n\nconst {\n  RawSource\n} = require(\"webpack-sources\");\n\nconst FontTypes = require(\"./FontTypes\");\n\nconst API_URL = \"https://google-webfonts-helper.herokuapp.com/api/fonts\";\n\nconst FONT_SRC = (font, format) => `url(\"${font}\")${format ? ` format(\"${format}\")` : \"\"}`;\n\nconst FONT_FACE = ({\n  fontFamily,\n  fontStyle,\n  fontWeight,\n  src,\n  fallback\n}) => `\n@font-face {\n\tfont-family: ${fontFamily};\n\tfont-style: ${fontStyle};\n\tfont-weight: ${fontWeight};\n\t${fallback ? `src: ${fallback};` : \"\"}\n\t${src.length ? `src: ${src.join(\",\\n\\t\\t\")};` : \"\"}\n}\n`;\n\nfunction getVariantCss({\n  variant,\n  info,\n  font,\n  formats,\n  fontsPath\n}) {\n  const src = info.local.map(fileName => `local(\"${fileName}\")`);\n  let fallback;\n  formats.forEach(ext => {\n    if (ext in info) {\n      const url = typeof fontsPath !== \"undefined\" ? `./${fontsPath}/${font.getName(variant)}.${ext}` : info[ext];\n      const format = FontTypes[ext];\n      src.push(FONT_SRC(url, format));\n\n      if (ext === \"eot\") {\n        fallback = FONT_SRC(url);\n      }\n    }\n  });\n  return `/* === ${font.family} - ${variant} */` + FONT_FACE(_.assign({\n    src,\n    fallback\n  }, info));\n}\n\nclass Selection {\n  constructor(font, query, info) {\n    this.font = font;\n    this.query = {\n      subsets: query.subsets || font.defaults.subsets,\n      variants: query.variants || font.defaults.variants,\n      formats: query.formats || _.keys(FontTypes)\n    };\n    this.query.variants = this.query.variants.map(value => {\n      switch (value) {\n        case \"400\":\n          return \"regular\";\n\n        case \"400italic\":\n          return \"italic\";\n\n        default:\n          return value;\n      }\n    });\n  }\n\n  css(fontsPath) {\n    const {\n      font,\n      query: {\n        subsets,\n        variants,\n        formats\n      }\n    } = this;\n    return font.info(subsets).then(info => {\n      const css = [];\n      variants.forEach(variant => {\n        const variantInfo = info.variants.filter(node => node.id === variant).pop();\n\n        if (variantInfo) {\n          css.push(getVariantCss({\n            info: variantInfo,\n            formats,\n            variant,\n            font,\n            fontsPath\n          }));\n        }\n      });\n      return css.join(\"\\n\");\n    });\n  }\n\n  download() {\n    if (this._response) {\n      return Promise.resolve(this._response);\n    }\n\n    const {\n      font\n    } = this;\n    const {\n      subsets,\n      variants,\n      formats\n    } = this.query;\n    let url = `${font.url}?download=zip`;\n    url += \"&subsets=\" + subsets.join(\",\");\n    url += \"&variants=\" + variants.join(\",\");\n\n    if (formats) {\n      url += \"&formats=\" + formats.join(\",\");\n    }\n\n    return fetch(url).then(response => {\n      if (response.status !== 200) {\n        throw new Error(response.statusText);\n      }\n\n      this._response = response;\n      return response;\n    });\n  }\n\n  files() {\n    if (this._files) {\n      return Promise.resolve(this._files);\n    }\n\n    return this.download().then(response => response.buffer()).then(buffer => new Promise((resolve, reject) => {\n      this._files = {};\n      yauzl.fromBuffer(buffer, {\n        lazyEntries: true\n      }, (err, zipFile) => {\n        if (err) {\n          reject(err);\n        }\n\n        const next = () => zipFile.readEntry();\n\n        zipFile.on(\"error\", reject).on(\"end\", () => resolve(this._files)).on(\"entry\", entry => {\n          if (/\\/$/.test(entry.fileName)) next();\n          const ext = path.extname(entry.fileName).slice(1);\n          const variant = entry.fileName.match(/\\-([a-z0-9]+)\\..*$/)[1];\n          const fileName = `${this.font.getName(variant)}.${ext}`;\n          zipFile.openReadStream(entry, (err, stream) => {\n            if (err) reject(err);\n            const buffer = [];\n            stream.on(\"data\", data => buffer.push(data));\n            stream.on(\"end\", () => {\n              this._files[fileName] = Buffer.concat(buffer);\n              next();\n            });\n          });\n        });\n        zipFile.readEntry();\n      });\n    }));\n  }\n\n  assets() {\n    return this.files().then(files => {\n      const assets = {};\n\n      for (const fileName in files) {\n        assets[fileName] = new RawSource(files[fileName]);\n      }\n\n      return assets;\n    });\n  }\n\n}\n\nclass Font {\n  constructor(url, {\n    id,\n    family,\n    variants,\n    formats,\n    defSubset,\n    defVariant\n  }) {\n    this.apiUrl = url;\n    this.id = id;\n    this.family = family;\n    this.variants = variants;\n    this.formats = formats;\n    this.defaults = {\n      subsets: [defSubset],\n      variants: [defVariant]\n    };\n    this.getName = this.getName.bind(this);\n  }\n\n  get url() {\n    return `${this.apiUrl}/${this.id}`;\n  }\n\n  getName(variant) {\n    let name = _.chain(this.family).camelCase().upperFirst().value();\n\n    if (variant) {\n      const weight = parseInt(variant.substr(0, 3));\n      let suffix = \"Regular\";\n\n      switch (weight) {\n        case 100:\n          suffix = \"Thin\";\n          break;\n\n        case 200:\n          suffix = \"ExtraLight\";\n          break;\n\n        case 300:\n          suffix = \"Light\";\n          break;\n\n        case 400:\n          suffix = \"Regular\";\n          break;\n\n        case 500:\n          suffix = \"Medium\";\n          break;\n\n        case 600:\n          suffix = \"SemiBold\";\n          break;\n\n        case 700:\n          suffix = \"Bold\";\n          break;\n\n        case 800:\n          suffix = \"ExtraBold\";\n          break;\n\n        case 900:\n          suffix = \"Black\";\n          break;\n      }\n\n      if (/italic$/.test(variant)) {\n        suffix = suffix === \"Regular\" ? \"Italic\" : `${suffix}Italic`;\n      }\n\n      name += `-${suffix}`;\n    }\n\n    return name;\n  }\n\n  info(subsets) {\n    if (this._info) {\n      return Promise.resolve(this._info);\n    }\n\n    let url = this.url + \"?\";\n\n    if (subsets) {\n      url += \"subsets=\" + subsets.join(\",\");\n    }\n\n    return fetch(url).then(response => {\n      if (response.status !== 200) {\n        throw new Error(response.statusText);\n      }\n\n      return response.json();\n    }).then(info => {\n      this._info = info;\n      return info;\n    });\n  }\n\n  select(options = {}) {\n    return new Selection(this, options);\n  }\n\n}\n\nclass GoogleWebfonts {\n  constructor(apiUrl = API_URL) {\n    this.url = apiUrl;\n  }\n\n  getFonts() {\n    if (this._fonts) {\n      return Promise.resolve(this._fonts);\n    } else {\n      return fetch(this.url).then(response => {\n        if (response.status !== 200) {\n          throw new Error(response.statusText);\n        }\n\n        return response.json();\n      }).then(fonts => fonts.map(font => new Font(this.url, font))).then(fonts => {\n        this._fonts = fonts;\n        return fonts;\n      });\n    }\n  }\n\n  getFontById(id) {\n    return this.getFonts().then(fonts => fonts.filter(font => font.id === id).pop());\n  }\n\n  getFontByFamily(family) {\n    return this.getFonts().then(fonts => fonts.filter(font => font.family.toLowerCase() === family.toLowerCase()).pop());\n  }\n\n}\n\nGoogleWebfonts.Font = Font;\nGoogleWebfonts.Selection = Selection;\nmodule.exports = GoogleWebfonts;","map":{"version":3,"names":["_","require","path","yauzl","fetch","RawSource","FontTypes","API_URL","FONT_SRC","font","format","FONT_FACE","fontFamily","fontStyle","fontWeight","src","fallback","length","join","getVariantCss","variant","info","formats","fontsPath","local","map","fileName","forEach","ext","url","getName","push","family","assign","Selection","constructor","query","subsets","defaults","variants","keys","value","css","then","variantInfo","filter","node","id","pop","download","_response","Promise","resolve","response","status","Error","statusText","files","_files","buffer","reject","fromBuffer","lazyEntries","err","zipFile","next","readEntry","on","entry","test","extname","slice","match","openReadStream","stream","data","Buffer","concat","assets","Font","defSubset","defVariant","apiUrl","bind","name","chain","camelCase","upperFirst","weight","parseInt","substr","suffix","_info","json","select","options","GoogleWebfonts","getFonts","_fonts","fonts","getFontById","getFontByFamily","toLowerCase","module","exports"],"sources":["/home/xavi/Desktop/TRABAJOS/SpringFood/FE/springfood/node_modules/google-fonts-webpack-plugin/src/GoogleWebfonts.js"],"sourcesContent":["const _ = require(\"lodash\")\nconst path = require(\"path\")\nconst yauzl = require(\"yauzl\")\nconst fetch = require(\"node-fetch\")\nconst { RawSource } = require(\"webpack-sources\")\nconst FontTypes = require(\"./FontTypes\")\n\nconst API_URL = \"https://google-webfonts-helper.herokuapp.com/api/fonts\"\n\nconst FONT_SRC = (font, format) => `url(\"${font}\")${format ? ` format(\"${format}\")` : \"\"}`\n\nconst FONT_FACE = ({ fontFamily, fontStyle, fontWeight, src, fallback }) => `\n@font-face {\n\tfont-family: ${fontFamily};\n\tfont-style: ${fontStyle};\n\tfont-weight: ${fontWeight};\n\t${fallback ? `src: ${fallback};` : \"\"}\n\t${src.length ? `src: ${src.join(\",\\n\\t\\t\")};` : \"\"}\n}\n`\n\nfunction getVariantCss({ variant, info, font, formats, fontsPath }) {\n\tconst src = info.local.map(fileName => `local(\"${fileName}\")`)\n\tlet fallback\n\tformats.forEach(ext => {\n\t\tif(ext in info) {\n\t\t\tconst url = (\n\t\t\t\ttypeof fontsPath !== \"undefined\" ?\n\t\t\t\t`./${fontsPath}/${font.getName(variant)}.${ext}` :\n\t\t\t\tinfo[ext]\n\t\t\t)\n\t\t\tconst format = FontTypes[ext]\n\t\t\tsrc.push(FONT_SRC(url, format))\n\t\t\tif(ext === \"eot\") {\n\t\t\t\tfallback = FONT_SRC(url)\n\t\t\t}\n\t\t}\n\t})\n\treturn (\n\t\t`/* === ${font.family} - ${variant} */` +\n\t\tFONT_FACE(_.assign({ src, fallback }, info))\n\t)\n}\n\nclass Selection {\n\tconstructor(font, query, info) {\n\t\tthis.font = font\n\t\tthis.query = {\n\t\t\tsubsets: query.subsets || font.defaults.subsets,\n\t\t\tvariants: query.variants || font.defaults.variants,\n\t\t\tformats: query.formats || _.keys(FontTypes)\n\t\t}\n\t\tthis.query.variants = this.query.variants.map(value => {\n\t\t\tswitch(value) {\n\t\t\t\tcase \"400\": return \"regular\"\n\t\t\t\tcase \"400italic\": return \"italic\"\n\t\t\t\tdefault: return value\n\t\t\t}\n\t\t})\n\t}\n\n\tcss(fontsPath) {\n\t\tconst { font, query: { subsets, variants, formats } } = this\n\t\treturn font.info(subsets)\n\t\t\t.then(info => {\n\t\t\t\tconst css = []\n\t\t\t\tvariants.forEach(variant => {\n\t\t\t\t\tconst variantInfo = info.variants.filter(node => node.id === variant).pop()\n\t\t\t\t\tif(variantInfo) {\n\t\t\t\t\t\tcss.push(getVariantCss({\n\t\t\t\t\t\t\tinfo: variantInfo,\n\t\t\t\t\t\t\tformats,\n\t\t\t\t\t\t\tvariant,\n\t\t\t\t\t\t\tfont,\n\t\t\t\t\t\t\tfontsPath\n\t\t\t\t\t\t}))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn css.join(\"\\n\")\n\t\t\t})\n\t}\n\n\tdownload() {\n\t\tif(this._response) {\n\t\t\treturn Promise.resolve(this._response)\n\t\t}\n\t\tconst { font } = this\n\t\tconst { subsets, variants, formats } = this.query\n\t\tlet url = `${font.url}?download=zip`\n\t\turl += \"&subsets=\" + subsets.join(\",\")\n\t\turl += \"&variants=\" + variants.join(\",\")\n\t\tif(formats) {\n\t\t\turl += \"&formats=\" + formats.join(\",\")\n\t\t}\n\t\treturn fetch(url)\n\t\t\t.then(response => {\n\t\t\t\tif(response.status !== 200) {\n\t\t\t\t\tthrow new Error(response.statusText)\n\t\t\t\t}\n\t\t\t\tthis._response = response\n\t\t\t\treturn response\n\t\t\t})\n\t}\n\n\tfiles() {\n\t\tif(this._files) {\n\t\t\treturn Promise.resolve(this._files)\n\t\t}\n\t\treturn this.download()\n\t\t\t.then(response => response.buffer())\n\t\t\t.then(buffer => new Promise((resolve, reject) => {\n\t\t\t\tthis._files = {}\n\t\t\t\tyauzl.fromBuffer(buffer, { lazyEntries: true }, (err, zipFile) => {\n\t\t\t\t\tif(err) {\n\t\t\t\t\t\treject(err)\n\t\t\t\t\t}\n\t\t\t\t\tconst next = () => zipFile.readEntry()\n\t\t\t\t\tzipFile\n\t\t\t\t\t\t.on(\"error\", reject)\n\t\t\t\t\t\t.on(\"end\", () => resolve(this._files))\n\t\t\t\t\t\t.on(\"entry\", entry => {\n\t\t\t\t\t\t\tif(/\\/$/.test(entry.fileName)) next()\n\t\t\t\t\t\t\tconst ext = path.extname(entry.fileName).slice(1)\n\t\t\t\t\t\t\tconst variant = entry.fileName.match(/\\-([a-z0-9]+)\\..*$/)[1]\n\t\t\t\t\t\t\tconst fileName = `${this.font.getName(variant)}.${ext}`\n\t\t\t\t\t\t\tzipFile.openReadStream(entry, (err, stream) => {\n\t\t\t\t\t\t\t\tif(err) reject(err)\n\t\t\t\t\t\t\t\tconst buffer = []\n\t\t\t\t\t\t\t\tstream.on(\"data\", data => buffer.push(data))\n\t\t\t\t\t\t\t\tstream.on(\"end\", () => {\n\t\t\t\t\t\t\t\t\tthis._files[fileName] = Buffer.concat(buffer)\n\t\t\t\t\t\t\t\t\tnext()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t})\n\t\t\t\t\tzipFile.readEntry()\n\t\t\t\t})\n\t\t\t}))\n\t}\n\n\tassets() {\n\t\treturn this.files()\n\t\t\t.then(files => {\n\t\t\t\tconst assets = {}\n\t\t\t\tfor(const fileName in files) {\n\t\t\t\t\tassets[fileName] = new RawSource(files[fileName])\n\t\t\t\t}\n\t\t\t\treturn assets\n\t\t\t})\n\t}\n}\n\nclass Font {\n\tconstructor(url, { id, family, variants, formats, defSubset, defVariant }) {\n\t\tthis.apiUrl = url\n\t\tthis.id = id\n\t\tthis.family = family\n\t\tthis.variants = variants\n\t\tthis.formats = formats\n\t\tthis.defaults = {\n\t\t\tsubsets: [ defSubset ],\n\t\t\tvariants: [ defVariant ]\n\t\t}\n\t\tthis.getName = this.getName.bind(this)\n\t}\n\n\tget url() { return `${this.apiUrl}/${this.id}` }\n\n\tgetName(variant) {\n\t\tlet name = _.chain(this.family).camelCase().upperFirst().value()\n\t\tif(variant) {\n\t\t\tconst weight = parseInt(variant.substr(0, 3))\n\t\t\tlet suffix = \"Regular\"\n\t\t\tswitch(weight) {\n\t\t\t\tcase 100: suffix = \"Thin\"; break;\n\t\t\t\tcase 200: suffix = \"ExtraLight\"; break;\n\t\t\t\tcase 300: suffix = \"Light\"; break;\n\t\t\t\tcase 400: suffix = \"Regular\"; break;\n\t\t\t\tcase 500: suffix = \"Medium\"; break;\n\t\t\t\tcase 600: suffix = \"SemiBold\"; break;\n\t\t\t\tcase 700: suffix = \"Bold\"; break;\n\t\t\t\tcase 800: suffix = \"ExtraBold\"; break;\n\t\t\t\tcase 900: suffix = \"Black\"; break;\n\t\t\t}\n\t\t\tif(/italic$/.test(variant)) {\n\t\t\t\tsuffix = (suffix === \"Regular\" ? \"Italic\" : `${suffix}Italic`)\n\t\t\t}\n\t\t\tname += `-${suffix}`\n\t\t}\n\t\treturn name\n\t}\n\n\tinfo(subsets) {\n\t\tif(this._info) {\n\t\t\treturn Promise.resolve(this._info)\n\t\t}\n\t\tlet url = this.url + \"?\"\n\t\tif(subsets) {\n\t\t\turl += \"subsets=\" + subsets.join(\",\")\n\t\t}\n\t\treturn fetch(url)\n\t\t\t.then(response => {\n\t\t\t\tif(response.status !== 200) {\n\t\t\t\t\tthrow new Error(response.statusText)\n\t\t\t\t}\n\t\t\t\treturn response.json()\n\t\t\t})\n\t\t\t.then(info => {\n\t\t\t\tthis._info = info\n\t\t\t\treturn info\n\t\t\t})\n\t}\n\n\tselect(options = {}) {\n\t\treturn new Selection(this, options)\n\t}\n}\n\nclass GoogleWebfonts {\n\tconstructor(apiUrl = API_URL) {\n\t\tthis.url = apiUrl\n\t}\n\n\tgetFonts() {\n\t\tif(this._fonts) {\n\t\t\treturn Promise.resolve(this._fonts)\n\t\t} else {\n\t\t\treturn fetch(this.url)\n\t\t\t\t.then(response => {\n\t\t\t\t\tif(response.status !== 200) {\n\t\t\t\t\t\tthrow new Error(response.statusText)\n\t\t\t\t\t}\n\t\t\t\t\treturn response.json()\n\t\t\t\t})\n\t\t\t\t.then(fonts => fonts.map(font => new Font(this.url, font)))\n\t\t\t\t.then(fonts => {\n\t\t\t\t\tthis._fonts = fonts\n\t\t\t\t\treturn fonts\n\t\t\t\t})\n\t\t}\n\t}\n\n\tgetFontById(id) {\n\t\treturn this.getFonts()\n\t\t\t.then(fonts => fonts.filter(font => font.id === id).pop())\n\t}\n\n\tgetFontByFamily(family) {\n\t\treturn this.getFonts()\n\t\t\t.then(fonts => fonts.filter(font => font.family.toLowerCase() === family.toLowerCase()).pop())\n\t}\n}\n\nGoogleWebfonts.Font = Font\n\nGoogleWebfonts.Selection = Selection\n\nmodule.exports = GoogleWebfonts\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}